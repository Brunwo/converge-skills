#!/bin/bash
set -euo pipefail

SKILLS_ACTIVE="skills"
SKILLS_REPOS="skills-repos"
SKILLS_USER="skills-user"
CONFIG=".skillsync/active-skills.json"

# Initialize config directory
mkdir -p .skillsync

# Add sparse submodule
add_sparse_submodule() {
    local url=$1
    local name=""
    local initial_paths=""
    local ref=""

    # URL is always $1
    url=$1

    # Always extract repo name from URL first
    if [[ "$url" =~ github\.com[/:]([^/]+)/([^/.]+) ]]; then
        local user="${BASH_REMATCH[1]}"
        local repo="${BASH_REMATCH[2]}"
        local default_name="${user}-${repo}"
    else
        # Fallback: use last part of URL
        local default_name=$(basename "$url" .git)
    fi

    # Check if $2 looks like patterns (contains / or starts with skills/)
    if [[ "$2" =~ / ]] || [[ "$2" =~ ^skills/ ]]; then
        # $2 looks like patterns, use default name from URL
        name="$default_name"
        initial_paths=$2
        ref=${3:-}
    else
        # Traditional format: url name [paths] [ref]
        # If $2 is provided and doesn't look like patterns, use it as custom name
        if [ -n "$2" ]; then
            name=$2
        else
            name="$default_name"
        fi
        initial_paths=${3:-}
        ref=${4:-}
    fi

    echo "Adding sparse submodule: $name (from $url)"

    # Add as submodule (with optional branch or commit)
    if [ -n "$ref" ]; then
        # Check if it's a commit hash (40 characters, hex) or branch name
        if [[ "$ref" =~ ^[0-9a-f]{40}$ ]]; then
            # It's a commit hash - add submodule normally
            git submodule add "$url" "$SKILLS_REPOS/$name"
        else
            # It's a branch name - use -b flag
            git submodule add -b "$ref" "$url" "$SKILLS_REPOS/$name"
        fi
    else
        git submodule add "$url" "$SKILLS_REPOS/$name"
    fi

    # Configure sparse checkout
    cd "$SKILLS_REPOS/$name"
    git sparse-checkout init --cone
    git config core.sparseCheckout true

    # If it's a commit hash, checkout to that specific commit
    if [[ "$ref" =~ ^[0-9a-f]{40}$ ]]; then
        git checkout "$ref"
        # Reapply sparse checkout after commit checkout
        git sparse-checkout init --cone
        git config core.sparseCheckout true
    fi

    # Clear working directory of tracked files not in sparse pattern
    git ls-files | grep -v '^\.git' | xargs -r rm -f
    # Also remove any remaining files/directories except .git
    find . -maxdepth 1 -name '.git' -prune -o -type f -print | grep -v '^\./\.git' | xargs -r rm -f
    find . -maxdepth 1 -name '.git' -prune -o -type d -print | grep -v '^\./\.git' | xargs -r rm -rf

    # Determine sparse checkout patterns
    local sparse_patterns=""
    if [ -n "$initial_paths" ]; then
        # User specified specific patterns
        sparse_patterns="$initial_paths"
        git sparse-checkout set --skip-checks $sparse_patterns
    else
        # No patterns specified - add ALL skills from repository
        echo "No patterns specified, adding all skills from repository..."

        # First, do a minimal checkout to see repository structure
        git sparse-checkout set --skip-checks "README.md" "skills/" "*/"
        git checkout HEAD

        # Detect repository structure and collect all skills
        if [ -d "skills" ] && [ "$(find skills -maxdepth 1 -type d | wc -l)" -gt 1 ]; then
            # Vercel-style: skills in subdirectory
            echo "Detected Vercel-style repository structure (skills/ subdirectory)"
            local skill_dirs=$(find skills -maxdepth 1 -type d -not -name skills | sed 's|^skills/|skills/|')
            sparse_patterns=""
            for dir in $skill_dirs; do
                sparse_patterns="$sparse_patterns $dir/*"
            done
            sparse_patterns=$(echo "$sparse_patterns" | sed 's/^ *//')  # Remove leading space
        else
            # Cloudflare-style: skills in root or other structure
            echo "Detected root-level or Cloudflare-style repository structure"
            local skill_dirs=$(find . -maxdepth 1 -type d -not -name .git -not -name . -not -name skills | head -10)
            sparse_patterns=""
            for dir in $skill_dirs; do
                local dirname=$(basename "$dir")
                # Skip common non-skill directories
                if [[ "$dirname" != ".git" ]] && [[ "$dirname" != "docs" ]] && [[ "$dirname" != "scripts" ]] && [[ "$dirname" != ".github" ]]; then
                    sparse_patterns="$sparse_patterns $dirname"
                fi
            done
            sparse_patterns=$(echo "$sparse_patterns" | sed 's/^ *//')  # Remove leading space
        fi

        if [ -n "$sparse_patterns" ]; then
            echo "Adding all skills: $sparse_patterns"
            git sparse-checkout set --skip-checks $sparse_patterns
        else
            echo "Warning: No skills found in repository"
            sparse_patterns=""
        fi
    fi

    # Checkout only sparse files and update index
    git checkout HEAD  # Make sure we're on the correct ref
    git read-tree -mu HEAD  # Update index to match sparse patterns

    cd ../..

    # Save to .gitmodules metadata
    git config -f .gitmodules "submodule.$SKILLS_REPOS/$name.sparse" "true"
    git config -f .gitmodules "submodule.$SKILLS_REPOS/$name.sparse-checkout" "$sparse_patterns"
}

# Activate skills (create symlinks)
activate_skills() {
    local skills_json=$1

    # Create/clear active directory
    mkdir -p "$SKILLS_ACTIVE"

    # Remove old symlinks
    find "$SKILLS_ACTIVE" -type l -delete

    # Parse JSON and create symlinks
    echo "$skills_json" | jq -r '.[] | "\(.id)|\(.source)|\(.path)"' | while IFS='|' read -r id source path; do
        local target
        case "$source" in
            user)
                target="../$SKILLS_USER/$path"
                ;;
            *)
                # Check for both repository structures: with and without skills/ subdirectory
                if [ -d "$SKILLS_REPOS/$source/skills/$path" ]; then
                    target="../$SKILLS_REPOS/$source/skills/$path"
                elif [ -d "$SKILLS_REPOS/$source/$path" ]; then
                    target="../$SKILLS_REPOS/$source/$path"
                else
                    target="../$SKILLS_REPOS/$source/skills/$path"  # Default to skills/ subdirectory
                fi
                ;;
        esac

        if [ -d "${target#../}" ]; then
            ln -sf "$target" "$SKILLS_ACTIVE/$id"
            echo "✓ Activated: $id → $target"
        else
            echo "⚠ Warning: $target not found, skipping $id"
        fi
    done

    # Save config
    echo "$skills_json" | jq '.' > "$CONFIG"
}

# Add skill to sparse checkout and activate
add_skill() {
    local source=$1
    local skill_path=$2
    local skill_id=${3:-$(basename "$skill_path")}

    # Update sparse checkout
    if [ "$source" != "user" ]; then
        cd "$SKILLS_REPOS/$source"

        # Check repository structure and add appropriate pattern
        if [ -d "skills/$skill_path" ]; then
            # Repository has skills/ subdirectory (like Vercel)
            git sparse-checkout add --skip-checks "skills/$skill_path/*"
            git checkout HEAD  # materialize files
        elif [ -d "$skill_path" ]; then
            # Repository has skills directly in root (like Cloudflare)
            git sparse-checkout add --skip-checks "$skill_path"
            git checkout HEAD  # materialize files
        fi

        cd ../..

        # Update .gitmodules (only if we added a skills/ pattern)
        if [ -d "$SKILLS_REPOS/$source/skills/$skill_path" ]; then
            local current=$(git config -f .gitmodules "submodule.$SKILLS_REPOS/$source.sparse-checkout" || echo "")
            git config -f .gitmodules "submodule.$SKILLS_REPOS/$source.sparse-checkout" "$current skills/$skill_path/*"
        fi
    fi

    # Add to config
    local new_skill=$(jq -n \
        --arg id "$skill_id" \
        --arg source "$source" \
        --arg path "$skill_path" \
        '{id: $id, source: $source, path: $path}')

    if [ -f "$CONFIG" ]; then
        local updated=$(jq --argjson new "$new_skill" '. + [$new]' "$CONFIG")
    else
        local updated="[$new_skill]"
    fi

    activate_skills "$updated"
}

# Remove skill
remove_skill() {
    local skill_id=$1

    # Remove from config
    local updated=$(jq --arg id "$skill_id" 'map(select(.id != $id))' "$CONFIG")

    # Remove symlink
    rm -f "$SKILLS_ACTIVE/$skill_id"

    echo "$updated" | jq '.' > "$CONFIG"
    echo "✗ Deactivated: $skill_id"
}

# List active skills
list_skills() {
    if [ -f "$CONFIG" ]; then
        jq -r '.[] | "\(.id)\t(\(.source):\(.path))"' "$CONFIG"
    else
        echo "No skills activated yet"
    fi
}

# Restore from config (for post-clone/post-checkout)
restore() {
    if [ ! -f "$CONFIG" ]; then
        echo "No saved configuration found"
        exit 1
    fi

    local skills=$(cat "$CONFIG")
    activate_skills "$skills"
}

# Remove entire repository (and all its skills)
remove_repo() {
    local repo_name=$1
    local mode=${2:-hard}  # Default to hard removal
    local force=${3:-false}  # Default to no force

    echo "Removing repository: $repo_name (mode: $mode)"

    # For hard removal, check for uncommitted/unpushed changes
    if [ "$mode" = "hard" ] && [ "$force" = "false" ]; then
        if [ -d "skills-repos/$repo_name" ]; then
            cd "skills-repos/$repo_name"

            # Check for uncommitted changes
            if ! git diff --quiet --exit-code || ! git diff --cached --quiet --exit-code; then
                echo "❌ Error: Repository '$repo_name' has uncommitted changes."
                echo "   Use --force --hard to skip this safety check and lose changes."
                cd ../..
                exit 1
            fi

            # Check for unpushed commits
            local current_branch=$(git rev-parse --abbrev-ref HEAD)
            if git log --oneline --not --remotes | grep -q .; then
                echo "❌ Error: Repository '$repo_name' has local commits not pushed to remote."
                echo "   Use --force --hard to skip this safety check and lose commits."
                cd ../..
                exit 1
            fi

            cd ../..
        fi
    fi

    # Remove all skills from this repo
    if [ -f "$CONFIG" ]; then
        local updated=$(jq --arg repo "$repo_name" 'map(select(.source != $repo))' "$CONFIG")
        echo "$updated" | jq '.' > "$CONFIG"
    fi

    # Remove symlinks for this repo's skills
    find "$SKILLS_ACTIVE" -type l | while read -r link; do
        local target=$(readlink "$link")
        if [[ "$target" == *"../skills-repos/$repo_name"* ]]; then
            rm -f "$link"
        fi
    done

    if [ "$mode" = "hard" ]; then
        # Hard removal: delete submodule completely
        git submodule deinit -f "skills-repos/$repo_name"
        git rm -f "skills-repos/$repo_name"
        rm -rf ".git/modules/skills-repos/$repo_name"
        if [ "$force" = "true" ]; then
            echo "✗ Force hard removed repository: $repo_name (changes may be lost)"
        else
            echo "✗ Hard removed repository: $repo_name"
        fi
    else
        # Soft removal: unregister submodule but keep the files (only remove active skill symlinks)
        git submodule deinit -f "skills-repos/$repo_name" 2>/dev/null || true

        # Stage .gitmodules changes first, then remove from index and .gitmodules
        git add .gitmodules 2>/dev/null || true
        git rm --cached "skills-repos/$repo_name" 2>/dev/null || true  # Remove from index only, keep files

        # Clean up any leftover git modules
        if [ -d ".git/modules/skills-repos/$repo_name" ]; then
            rm -rf ".git/modules/skills-repos/$repo_name"
        fi

        echo "✗ Soft removed repository: $repo_name (files preserved, symlinks removed)"
    fi
}

# Main command dispatcher
case "${1:-}" in
    add-repo)
        # Handle variable number of arguments for add-repo
        arg2="${2:-}"
        arg3="${3:-}"
        arg4="${4:-}"
        arg5="${5:-}"
        add_sparse_submodule "$arg2" "$arg3" "$arg4" "$arg5"
        ;;
    remove-repo)
        case "${2:-}" in
            --soft)
                remove_repo "$3" "soft" "false"
                ;;
            --force)
                case "${3:-}" in
                    --hard)
                        remove_repo "$4" "hard" "true"
                        ;;
                    *)
                        echo "❌ Error: --force must be used with --hard"
                        exit 1
                        ;;
                esac
                ;;
            --hard)
                remove_repo "$3" "hard" "false"
                ;;
            *)
                remove_repo "$2" "hard" "false"
                ;;
        esac
        ;;
    add)
        add_skill "$2" "$3" "${4:-}"
        ;;
    remove)
        remove_skill "$2"
        ;;
    list)
        list_skills
        ;;
    restore)
        restore
        ;;
    *)
        cat << 'EOF'
Usage: skillsync <command> [args]

Commands:
  add-repo <url> [name] [initial_paths] [branch]   Add sparse submodule (name auto-extracted from URL if omitted)
  remove-repo [--soft|--hard] [--force] <name>    Remove repository (--soft preserves files)
  add <source> <path> [id]                 Activate skill
  remove <id>                              Deactivate skill
  list                                     List active skills
  restore                                  Restore symlinks from config

Examples:
  # Default: auto-extract repo name and add ALL skills from repository
  skillsync add-repo https://github.com/vercel-labs/agent-skills
  skillsync add-repo https://github.com/cloudflare/skills

  # Specific skills: auto-extract repo name but specify patterns
  skillsync add-repo https://github.com/vercel-labs/agent-skills "skills/react-best-practices/"
  skillsync add-repo https://github.com/cloudflare/skills "agents-sdk/"

  # Traditional: specify custom name
  skillsync add-repo https://github.com/base-org/skills base "skills/postgres-patterns/*"
  skillsync add-repo https://github.com/vercel-labs/agent-skills vercel "skills/" install

  # Repository management
  skillsync remove-repo vercel                    # Hard removal (default)
  skillsync remove-repo --soft vercel            # Soft removal (keeps files)

  # Skill management
  skillsync add agent-skills react-best-practices
  skillsync add skills agents-sdk
  skillsync list
  skillsync remove react-best-practices
EOF
        ;;
esac
