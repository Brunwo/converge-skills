#!/bin/bash
set -euo pipefail

SKILLS_ACTIVE="skills"
SKILLS_REPOS="skills-repos"
SKILLS_USER="skills-user"
CONFIG=".skillsync/active-skills.json"

# Config directory
mkdir_config() {
    mkdir -p .skillsync
}

# Ensure we are in a Git repository (except for 'install' and 'help')
check_git_repo() {
    if ! git rev-parse --is-inside-work-tree >/dev/null 2>&1; then
        echo "âŒ Error: Not a git repository. SkillSync commands must be run from the root of a project."
        exit 1
    fi
}

# Derive user-repo name from git URL
get_repo_name() {
    local url=$1
    if [[ "$url" =~ github\.com[/:]([^/]+)/([^/.]+) ]]; then
        echo "${BASH_REMATCH[1]}-${BASH_REMATCH[2]}"
    else
        basename "$url" .git
    fi
}

# Add sparse submodule
add_sparse_submodule() {
    local url=$1
    local name=""
    local initial_paths=""
    local ref=""

    # URL is always $1
    url=$1

    # Always extract repo name from URL first
    if [[ "$url" =~ github\.com[/:]([^/]+)/([^/.]+) ]]; then
        local user="${BASH_REMATCH[1]}"
        local repo="${BASH_REMATCH[2]}"
        local default_name="${user}-${repo}"
    else
        # Fallback: use last part of URL
        local default_name=$(basename "$url" .git)
    fi

    # Check if $2 looks like patterns (contains / or starts with skills/)
    if [[ "$2" =~ / ]] || [[ "$2" =~ ^skills/ ]]; then
        # $2 looks like patterns, use default name from URL
        name="$default_name"
        initial_paths=$2
        ref=${3:-}
    else
        # Traditional format: url name [paths] [ref]
        # If $2 is provided and doesn't look like patterns, use it as custom name
        if [ -n "$2" ]; then
            name=$2
        else
            name="$default_name"
        fi
        initial_paths=${3:-}
        ref=${4:-}
    fi

    echo "Adding sparse submodule: $name (from $url)"

    # Handle case where directory exists but is not a git repo (e.g. after soft removal)
    if [ -d "$SKILLS_REPOS/$name" ] && [ ! -e "$SKILLS_REPOS/$name/.git" ]; then
        echo "âš  Warning: Directory '$SKILLS_REPOS/$name' exists but is not a git repository. Clearing it for re-adding..."
        rm -rf "$SKILLS_REPOS/$name"
    fi

    # Add as submodule (with optional branch or commit) if not already in index
    if git ls-files --error-unmatch "$SKILLS_REPOS/$name" >/dev/null 2>&1; then
        echo "â„¹ Repository '$name' already in index, skipping 'submodule add'"
    else
        if [ -n "$ref" ]; then
            # Check if it's a commit hash (40 characters, hex) or branch name
            if [[ "$ref" =~ ^[0-9a-f]{40}$ ]]; then
                # It's a commit hash - add submodule normally
                git submodule add -q "$url" "$SKILLS_REPOS/$name"
            else
                # It's a branch name - use -b flag
                git submodule add -q -b "$ref" "$url" "$SKILLS_REPOS/$name"
            fi
        else
            git submodule add -q "$url" "$SKILLS_REPOS/$name"
        fi
    fi

    # Configure sparse checkout (non-cone mode to allow excluding root files)
    cd "$SKILLS_REPOS/$name"
    git sparse-checkout init --no-cone >/dev/null 2>&1

    # Determine sparse checkout patterns
    local sparse_patterns=""
    if [ -n "$initial_paths" ]; then
        # User specified specific patterns
        sparse_patterns="$initial_paths"
        git sparse-checkout set --no-cone --skip-checks $sparse_patterns
    else
        # No patterns specified - add ALL skills from repository
        echo "No patterns specified, adding all skills from repository..."

        # Detect repository structure and collect all skills via ls-tree
        # This is more robust as it doesn't require materializing files first
        if git ls-tree -d HEAD skills/ >/dev/null 2>&1; then
            # Vercel-style: skills in subdirectory
            echo "Detected Vercel-style repository structure (skills/ subdirectory)"
            local skill_dirs=$(git ls-tree -d HEAD skills/ | awk '{print $4}')
            sparse_patterns=""
            for dir in $skill_dirs; do
                sparse_patterns="$sparse_patterns $dir/*"
            done
            sparse_patterns=$(echo "$sparse_patterns" | sed 's/^ *//')  # Remove leading space
        else
            # Cloudflare-style: skills in root or other structure
            echo "Detected root-level or Cloudflare-style repository structure"
            # Get top level directories, exclude common ones
            local skill_dirs=$(git ls-tree -d HEAD | grep '^04' | awk '{print $4}')
            sparse_patterns=""
            for dir in $skill_dirs; do
                # Skip common non-skill directories
                if [[ "$dir" != "docs" ]] && [[ "$dir" != "scripts" ]] && [[ "$dir" != ".github" ]]; then
                    sparse_patterns="$sparse_patterns $dir/*"
                fi
            done
            sparse_patterns=$(echo "$sparse_patterns" | sed 's/^ *//')  # Remove leading space
        fi

        if [ -n "$sparse_patterns" ]; then
            echo "Adding all skills: $sparse_patterns"
            git sparse-checkout set --no-cone --skip-checks $sparse_patterns
        else
            echo "Warning: No skills found in repository"
            sparse_patterns=""
        fi
    fi

    # Now checkout the specific commit or update working tree to patterns
    if [[ "$ref" =~ ^[0-9a-f]{40}$ ]]; then
        git checkout -q "$ref"
    else
        git checkout -q HEAD
    fi

    cd ../..

    # Save to .gitmodules metadata
    git config -f .gitmodules "submodule.$SKILLS_REPOS/$name.sparse" "true"
    git config -f .gitmodules "submodule.$SKILLS_REPOS/$name.sparse-checkout" "$sparse_patterns"
}

# Activate skills (create symlinks)
activate_skills() {
    local skills_json=$1

    # Create/clear active directory
    mkdir -p "$SKILLS_ACTIVE"

    # Remove old symlinks
    find "$SKILLS_ACTIVE" -type l -delete

    # Parse JSON and create symlinks
    echo "$skills_json" | jq -r '.[] | "\(.id)|\(.source)|\(.path)"' | while IFS='|' read -r id source path; do
        local target
        case "$source" in
            user)
                target="../$SKILLS_USER/$path"
                ;;
            *)
                local repo_dir="$source"
                # If the exact source dir doesn't exist, try to find a matching one
                if [ ! -d "$SKILLS_REPOS/$repo_dir" ]; then
                    local match=$(ls "$SKILLS_REPOS" 2>/dev/null | grep "$source" | head -n 1 || echo "")
                    if [ -n "$match" ]; then
                        repo_dir="$match"
                    fi
                fi

                # Check for both repository structures: with and without skills/ subdirectory
                if [ -d "$SKILLS_REPOS/$repo_dir/skills/$path" ]; then
                    target="../$SKILLS_REPOS/$repo_dir/skills/$path"
                elif [ -d "$SKILLS_REPOS/$repo_dir/$path" ]; then
                    target="../$SKILLS_REPOS/$repo_dir/$path"
                else
                    target="../$SKILLS_REPOS/$repo_dir/skills/$path"  # Default to skills/ subdirectory
                fi
                ;;
        esac

        if [ -d "${target#../}" ]; then
            ln -sf "$target" "$SKILLS_ACTIVE/$id"
            echo "âœ“ Activated: $id â†’ $target"
        else
            echo "âš  Warning: $target not found, skipping $id"
        fi
    done

    # Save config
    echo "$skills_json" | jq '.' > "$CONFIG"
}

# Add skill or repo (handles both URLs and source names)
add_skill_or_repo() {
    local arg1="${1:-}"
    local arg2="${2:-.}"
    local arg3="${3:-}"
    local arg4="${4:-}"
    
    # Check if arg1 is a URL
    if [[ "$arg1" =~ ^https?:// ]]; then
        # URL provided - call add-repo then optionally add specific skill
        local url="$arg1"
        local path="$arg2"
        local ref="$arg3"
        
        # First ensure the repo exists and is configured
        local repo_name=$(get_repo_name "$url")
        local has_patterns=$(git config -f .gitmodules "submodule.$SKILLS_REPOS/$repo_name.sparse-checkout" || echo "")
        
        if [ ! -d "$SKILLS_REPOS/$repo_name" ] || [ -z "$has_patterns" ]; then
            # Add or re-configure the repo
            add_sparse_submodule "$url" "" "" "$ref"
        fi
        
        if [ "$path" != "." ]; then
            add_skill "$repo_name" "$path" "$arg4"
        else
            # Auto-activate all skills found in the repo
            echo "Auto-activating all skills from $repo_name..."
            local patterns=$(git config -f .gitmodules "submodule.$SKILLS_REPOS/$repo_name.sparse-checkout" || echo "")
            if [ -z "$patterns" ]; then
                echo "âš  No patterns found for $repo_name, skipping auto-activation"
            else
                for pattern in $patterns; do
                    # Clean up pattern (e.g. "skills/foo/*" -> "foo")
                    local clean_path=$(echo "$pattern" | sed 's|/\*$||' | sed 's|^skills/||')
                    if [ -n "$clean_path" ]; then
                        add_skill "$repo_name" "$clean_path" "" "skip-activation"
                    fi
                done
                restore
            fi
        fi
    else
        # Source name provided - existing workflow
        add_skill "$arg1" "$arg2" "$arg3"
    fi
}

# Add skill to sparse checkout and activate
add_skill() {
    local source=$1
    local skill_path=$2
    local skill_id=${3:-$(basename "$skill_path")}

    # Update sparse checkout
    if [ "$source" != "user" ]; then
        cd "$SKILLS_REPOS/$source"

        if [ -d "skills/$skill_path" ]; then
            # Repository has skills/ subdirectory (like Vercel)
            git sparse-checkout add --skip-checks "skills/$skill_path/*" >/dev/null 2>&1
            git checkout -q HEAD  # materialize files
        elif [ -d "$skill_path" ]; then
            # Repository has skills directly in root (like Cloudflare)
            git sparse-checkout add --skip-checks "$skill_path" >/dev/null 2>&1
            git checkout -q HEAD  # materialize files
        fi

        cd ../..

        # Update .gitmodules (only if we added a skills/ pattern)
        if [ -d "$SKILLS_REPOS/$source/skills/$skill_path" ]; then
            local current=$(git config -f .gitmodules "submodule.$SKILLS_REPOS/$source.sparse-checkout" || echo "")
            git config -f .gitmodules "submodule.$SKILLS_REPOS/$source.sparse-checkout" "$current skills/$skill_path/*"
        fi
    fi

    # Get current commit for version pinning
    local commit="null"
    if [ "$source" != "user" ] && [ -d "$SKILLS_REPOS/$source" ]; then
        commit=$(git -C "$SKILLS_REPOS/$source" rev-parse --short HEAD 2>/dev/null || echo "null")
    fi

    # Add to config (with commit for version pinning)
    local new_skill
    if [ "$commit" != "null" ]; then
        new_skill=$(jq -n \
            --arg id "$skill_id" \
            --arg source "$source" \
            --arg path "$skill_path" \
            --arg commit "$commit" \
            '{id: $id, source: $source, path: $path, commit: $commit}')
    else
        new_skill=$(jq -n \
            --arg id "$skill_id" \
            --arg source "$source" \
            --arg path "$skill_path" \
            '{id: $id, source: $source, path: $path}')
    fi

    if [ -f "$CONFIG" ]; then
        local updated=$(jq --argjson new "$new_skill" '. + [$new]' "$CONFIG")
    else
        local updated="[$new_skill]"
    fi

    if [ "${4:-}" != "skip-activation" ]; then
        activate_skills "$updated"
    else
        # Save config even if skipping activation
        echo "$updated" | jq '.' > "$CONFIG"
    fi
}

# Remove skill
remove_skill() {
    local skill_id=$1

    # Remove from config
    local updated=$(jq --arg id "$skill_id" 'map(select(.id != $id))' "$CONFIG")

    # Remove symlink
    rm -f "$SKILLS_ACTIVE/$skill_id"

    echo "$updated" | jq '.' > "$CONFIG"
    echo "âœ— Deactivated: $skill_id"
}

# Deactivate all skills associated with a repository
deactivate_repo_skills() {
    local repo_name=$1
    
    echo "Deactivating all skills from repository: $repo_name"

    # Remove all skills from this repo from the config
    if [ -f "$CONFIG" ]; then
        local updated=$(jq --arg repo "$repo_name" 'map(select(.source != $repo))' "$CONFIG")
        echo "$updated" | jq '.' > "$CONFIG"
    fi

    # Remove symlinks for this repo's skills
    if [ -d "$SKILLS_ACTIVE" ]; then
        # Find all symlinks in skills/ that point to the target repo and remove them
        # We use a pattern that matches the relative symlink target structure
        find "$SKILLS_ACTIVE" -type l -lname "*../$SKILLS_REPOS/$repo_name/*" -delete
    fi
}

# Remove skill or repo (handles both URLs and skill IDs)
remove_skill_or_repo() {
    local arg1="${1:-}"
    local arg2="${2:-}"
    
    # Check if arg1 is a URL
    if [[ "$arg1" =~ ^https?:// ]]; then
        # URL provided - extract repo name
        local repo_name=$(get_repo_name "$arg1")
        
        if [ -n "$arg2" ]; then
            # Specific skill deactivated from this repo
            # Search for skill matching this source and (path or id)
            local skill_id=$(jq -r --arg src "$repo_name" --arg p "$arg2" '.[] | select(.source == $src and (.path == $p or .id == $p)) | .id' "$CONFIG" 2>/dev/null | head -n 1 || echo "")
            
            if [ -n "$skill_id" ]; then
                remove_skill "$skill_id"
            else
                # Also try matching by basename of path
                skill_id=$(jq -r --arg src "$repo_name" --arg p "$arg2" '.[] | select(.source == $src and (.path | endswith($p))) | .id' "$CONFIG" 2>/dev/null | head -n 1 || echo "")
                if [ -n "$skill_id" ]; then
                    remove_skill "$skill_id"
                else
                    echo "âš  Warning: Skill '$arg2' not found in repository '$repo_name' (active-skills.json)"
                fi
            fi
        else
            # Deactivate all skills from this repo
            deactivate_repo_skills "$repo_name"
            echo "âœ— Deactivated all skills from: $arg1 (repository preserved)"
        fi
    else
        # Skill ID provided
        remove_skill "$arg1"
    fi
}

# List active skills
list_skills() {
    if [ -f "$CONFIG" ]; then
        jq -r '.[] | "\(.id)\t(\(.source):\(.path))"' "$CONFIG"
    else
        echo "No skills activated yet"
    fi
}

# Restore from config (for post-clone/post-checkout)
restore() {
    if [ ! -f "$CONFIG" ]; then
        echo "No saved configuration found"
        exit 1
    fi

    local skills=$(cat "$CONFIG")
    activate_skills "$skills"
}

# Remove entire repository (and all its skills)
remove_repo() {
    local repo_name=$1
    local mode=${2:-hard}  # Default to hard removal
    local force=${3:-false}  # Default to no force

    echo "Removing repository: $repo_name (mode: $mode)"

    # For hard removal, check for uncommitted/unpushed changes
    if [ "$mode" = "hard" ] && [ "$force" = "false" ]; then
        if [ -d "skills-repos/$repo_name" ]; then
            cd "skills-repos/$repo_name"

            # Check for uncommitted changes
            if ! git diff --quiet --exit-code || ! git diff --cached --quiet --exit-code; then
                echo "âŒ Error: Repository '$repo_name' has uncommitted changes."
                echo "   Use --force --hard to skip this safety check and lose changes."
                cd ../..
                exit 1
            fi

            # Check for unpushed commits
            local current_branch=$(git rev-parse --abbrev-ref HEAD)
            if git log --oneline --not --remotes | grep -q .; then
                echo "âŒ Error: Repository '$repo_name' has local commits not pushed to remote."
                echo "   Use --force --hard to skip this safety check and lose commits."
                cd ../..
                exit 1
            fi

            cd ../..
        fi
    fi

    # Deactivate all skills from this repo
    deactivate_repo_skills "$repo_name"

    if [ "$mode" = "hard" ]; then
        # Hard removal: delete submodule completely
        git add .gitmodules 2>/dev/null || true
        git submodule deinit -f "skills-repos/$repo_name"
        git rm -f "skills-repos/$repo_name"
        rm -rf ".git/modules/skills-repos/$repo_name"
        if [ "$force" = "true" ]; then
            echo "âœ— Force hard removed repository: $repo_name (changes may be lost)"
        else
            echo "âœ— Hard removed repository: $repo_name"
        fi
    else
        # Soft removal: unregister submodule but keep the files (only remove active skill symlinks)
        git submodule deinit -f "skills-repos/$repo_name" 2>/dev/null || true

        # Stage .gitmodules changes first, then remove from index and .gitmodules
        git add .gitmodules 2>/dev/null || true
        git rm --cached "skills-repos/$repo_name" 2>/dev/null || true  # Remove from index only, keep files

        # Clean up .gitmodules section explicitly
        git config -f .gitmodules --remove-section "submodule.skills-repos/$repo_name" 2>/dev/null || true
        git add .gitmodules 2>/dev/null || true

        # Clean up any leftover git modules
        if [ -d ".git/modules/skills-repos/$repo_name" ]; then
            rm -rf ".git/modules/skills-repos/$repo_name"
        fi

        echo "âœ— Soft removed repository: $repo_name (files preserved, symlinks removed)"
    fi
}

# Collect all submodule directories (handles nested structures like skills-repos/vercel/agent-skills)
_collect_repo_dirs() {
    local target="${1:-}"
    local dirs=""
    # Walk skills-repos/ and find directories that are git repos (have .git)
    # or are registered submodules
    while IFS= read -r dir; do
        [ -z "$dir" ] && continue
        local rel="${dir#$SKILLS_REPOS/}"
        # Filter by target if provided (match any path component)
        if [ -n "$target" ]; then
            if [[ "$rel" != *"$target"* ]]; then
                continue
            fi
        fi
        echo "$dir"
    done < <(find "$SKILLS_REPOS" -name ".git" -mindepth 2 2>/dev/null | while read -r gitpath; do
        dirname "$gitpath"
    done | sort)

    # Also find directories that are registered submodules but not initialized
    if [ -f .gitmodules ]; then
        grep 'path = ' .gitmodules | sed 's/.*path = //' | while read -r subpath; do
            [[ "$subpath" != "$SKILLS_REPOS"* ]] && continue
            if [ ! -e "$subpath/.git" ]; then
                if [ -n "$target" ]; then
                    [[ "$subpath" != *"$target"* ]] && continue
                fi
                echo "$subpath"
            fi
        done
    fi
}

# Show status of all skill repositories
show_status() {
    local target="${1:-}"
    local has_issues=false

    echo "ðŸ“Š SkillSync Status"
    echo "=================="

    # Collect all repo dirs (initialized + uninitialized submodules)
    local repo_dirs
    repo_dirs=$(_collect_repo_dirs "$target")

    if [ -z "$repo_dirs" ]; then
        echo ""
        echo "No skill repositories found."
        return
    fi

    while IFS= read -r dir; do
        [ -z "$dir" ] && continue
        local name="${dir#$SKILLS_REPOS/}"

        # Skip if not a git repo (submodule not initialized)
        if [ ! -e "$dir/.git" ]; then
            echo ""
            echo "âš  $name (not initialized)"
            echo "  Run: git submodule update --init $dir"
            has_issues=true
            continue
        fi

        echo ""
        echo "ðŸ“¦ $name"

        cd "$dir"

        # Current commit
        local current=$(git rev-parse --short HEAD 2>/dev/null || echo "unknown")
        local current_full=$(git rev-parse HEAD 2>/dev/null || echo "unknown")
        local branch=$(git rev-parse --abbrev-ref HEAD 2>/dev/null || echo "detached")
        echo "  commit: $current ($branch)"

        # Fetch to check upstream (silently)
        git fetch --quiet 2>/dev/null || true

        # Check how far behind upstream
        local tracking=$(git rev-parse --abbrev-ref '@{upstream}' 2>/dev/null || echo "")
        if [ -n "$tracking" ]; then
            local behind=$(git rev-list HEAD.."$tracking" --count 2>/dev/null || echo "?")
            local ahead=$(git rev-list "$tracking"..HEAD --count 2>/dev/null || echo "?")
            if [ "$behind" -gt 0 ] && [ "$ahead" -gt 0 ]; then
                echo "  â†• $behind behind, $ahead ahead of $tracking"
                has_issues=true
            elif [ "$behind" -gt 0 ]; then
                echo "  â†“ $behind commits behind $tracking"
                has_issues=true
            elif [ "$ahead" -gt 0 ]; then
                echo "  â†‘ $ahead commits ahead of $tracking"
            else
                echo "  âœ“ up to date with $tracking"
            fi
        else
            # No tracking branch, check against origin default
            local default_remote_ref=$(git symbolic-ref refs/remotes/origin/HEAD 2>/dev/null | sed 's|refs/remotes/||' || echo "")
            if [ -z "$default_remote_ref" ]; then
                # Try common branch names
                for try_branch in origin/main origin/master; do
                    if git rev-parse --verify "$try_branch" >/dev/null 2>&1; then
                        default_remote_ref="$try_branch"
                        break
                    fi
                done
            fi
            if [ -n "$default_remote_ref" ]; then
                local behind=$(git rev-list HEAD.."$default_remote_ref" --count 2>/dev/null || echo "?")
                if [ "$behind" -gt 0 ]; then
                    echo "  â†“ $behind commits behind $default_remote_ref"
                    has_issues=true
                else
                    echo "  âœ“ up to date with $default_remote_ref"
                fi
            else
                echo "  ? unable to determine upstream"
            fi
        fi

        # Check for local modifications
        if ! git diff --quiet --exit-code 2>/dev/null; then
            echo "  âš  has uncommitted changes"
            has_issues=true
        fi
        if ! git diff --cached --quiet --exit-code 2>/dev/null; then
            echo "  âš  has staged changes"
            has_issues=true
        fi

        cd - >/dev/null
    done <<< "$repo_dirs"

    # Check for broken symlinks
    echo ""
    echo "ðŸ”— Symlinks"
    local broken_count=0
    if [ -d "$SKILLS_ACTIVE" ]; then
        for link in "$SKILLS_ACTIVE"/*/; do
            [ -L "${link%/}" ] || continue
            if [ ! -e "${link%/}" ]; then
                echo "  âœ— broken: $(basename "${link%/}") â†’ $(readlink "${link%/}")"
                broken_count=$((broken_count + 1))
                has_issues=true
            fi
        done
        # Also check non-directory symlinks
        for link in "$SKILLS_ACTIVE"/*; do
            [ -L "$link" ] || continue
            [ -d "$link" ] && continue
            if [ ! -e "$link" ]; then
                echo "  âœ— broken: $(basename "$link") â†’ $(readlink "$link")"
                broken_count=$((broken_count + 1))
                has_issues=true
            fi
        done
    fi
    if [ "$broken_count" -eq 0 ]; then
        local total=$(find "$SKILLS_ACTIVE" -maxdepth 1 -type l 2>/dev/null | wc -l)
        echo "  âœ“ $total symlinks, all valid"
    else
        echo "  âš  $broken_count broken symlink(s) â€” run 'skillsync restore' to fix"
    fi

    echo ""
    if [ "$has_issues" = true ]; then
        echo "ðŸ’¡ Run 'skillsync sync' to update behind repos"
    else
        echo "âœ… Everything is in sync"
    fi
}

# Sync (pull upstream) for all or specific submodules
sync_repos() {
    local target="${1:-}"
    local dry_run="${2:-false}"
    local updated=0
    local failed=0

    echo "ðŸ”„ SkillSync â€” Syncing upstream"
    echo "================================"

    local repo_dirs
    repo_dirs=$(_collect_repo_dirs "$target")

    if [ -z "$repo_dirs" ]; then
        echo ""
        echo "No skill repositories found."
        return
    fi

    while IFS= read -r dir; do
        [ -z "$dir" ] && continue
        local name="${dir#$SKILLS_REPOS/}"

        # Skip if not initialized
        if [ ! -e "$dir/.git" ]; then
            echo ""
            echo "âš  $name â€” not initialized, skipping"
            continue
        fi

        echo ""
        echo "ðŸ“¦ $name"

        cd "$dir"

        local before=$(git rev-parse HEAD)

        # Fetch upstream
        if ! git fetch --quiet 2>/dev/null; then
            echo "  âœ— fetch failed"
            failed=$((failed + 1))
            cd - >/dev/null
            continue
        fi

        # Determine target ref
        local merge_ref=""
        local tracking=$(git rev-parse --abbrev-ref '@{upstream}' 2>/dev/null || echo "")
        if [ -n "$tracking" ]; then
            merge_ref="$tracking"
        else
            for try_branch in origin/main origin/master; do
                if git rev-parse --verify "$try_branch" >/dev/null 2>&1; then
                    merge_ref="$try_branch"
                    break
                fi
            done
        fi

        if [ -z "$merge_ref" ]; then
            echo "  ? cannot determine upstream ref, skipping"
            cd - >/dev/null
            continue
        fi

        local behind=$(git rev-list HEAD.."$merge_ref" --count 2>/dev/null || echo "0")

        if [ "$behind" -eq 0 ]; then
            echo "  âœ“ already up to date"
            cd - >/dev/null
            continue
        fi

        echo "  â†“ $behind new commits from $merge_ref"

        # Show summary of changes
        git log --oneline HEAD.."$merge_ref" | head -5
        if [ "$behind" -gt 5 ]; then
            echo "  ... and $((behind - 5)) more"
        fi

        if [ "$dry_run" = "true" ]; then
            echo "  (dry run â€” skipping merge)"
            cd - >/dev/null
            continue
        fi

        # Check for local modifications that would conflict
        if ! git diff --quiet --exit-code 2>/dev/null; then
            echo "  âš  has local changes â€” stashing before update"
            git stash --quiet
            local stashed=true
        else
            local stashed=false
        fi

        # Fast-forward merge
        if git merge --ff-only "$merge_ref" --quiet 2>/dev/null; then
            local after=$(git rev-parse --short HEAD)
            echo "  âœ“ updated: ${before:0:7} â†’ $after"
            updated=$((updated + 1))
        else
            echo "  âœ— cannot fast-forward (local commits exist). Manual merge needed."
            echo "    cd $SKILLS_REPOS/$name && git merge $merge_ref"
            failed=$((failed + 1))
        fi

        # Restore stashed changes
        if [ "$stashed" = true ]; then
            git stash pop --quiet 2>/dev/null || echo "  âš  stash pop had conflicts"
        fi

        cd - >/dev/null
    done <<< "$repo_dirs"

    echo ""
    echo "================================"
    if [ "$updated" -gt 0 ]; then
        echo "âœ… Updated $updated repo(s)"
        if [ "$dry_run" != "true" ]; then
            echo "ðŸ’¡ Commit the updated submodule pointers:"
            echo "   git add $SKILLS_REPOS && git commit -m \"sync: update skill repos\""
        fi
    else
        echo "âœ… All repos already up to date"
    fi
    if [ "$failed" -gt 0 ]; then
        echo "âš  $failed repo(s) need manual attention"
    fi
}

# Main command dispatcher
case "${1:-}" in
    add-repo)
        check_git_repo
        mkdir_config
        # Handle variable number of arguments for add-repo
        arg2="${2:-}"
        arg3="${3:-}"
        arg4="${4:-}"
        arg5="${5:-}"
        add_sparse_submodule "$arg2" "$arg3" "$arg4" "$arg5"
        ;;
    remove-repo)
        check_git_repo
        shift
        repo_name=""
        mode="hard"
        force="false"

        while [ $# -gt 0 ]; do
            case "$1" in
                --soft)
                    mode="soft"
                    shift
                    ;;
                --hard)
                    mode="hard"
                    shift
                    ;;
                --force)
                    force="true"
                    shift
                    ;;
                -*)
                    echo "âŒ Error: Unknown option $1"
                    exit 1
                    ;;
                *)
                    if [ -z "$repo_name" ]; then
                        repo_name="$1"
                    else
                        echo "âŒ Error: Multiple repository names provided: $repo_name, $1"
                        exit 1
                    fi
                    shift
                    ;;
            esac
        done

        if [ -z "$repo_name" ]; then
            echo "âŒ Error: Repository name not provided"
            exit 1
        fi

        if [ "$force" = "true" ] && [ "$mode" != "hard" ]; then
            echo "âŒ Error: --force must be used with --hard"
            exit 1
        fi

        remove_repo "$repo_name" "$mode" "$force"
        ;;
    add)
        check_git_repo
        mkdir_config
        add_skill_or_repo "$2" "${3:-.}" "${4:-}" "${5:-}"
        ;;
    remove)
        check_git_repo
        remove_skill_or_repo "$2" "${3:-}"
        ;;
    list)
        check_git_repo
        list_skills
        ;;
    restore)
        check_git_repo
        restore
        ;;
    status)
        check_git_repo
        show_status "${2:-}"
        ;;
    sync)
        check_git_repo
        shift
        sync_target=""
        sync_dry_run="false"
        while [ $# -gt 0 ]; do
            case "$1" in
                --dry-run) sync_dry_run="true"; shift ;;
                *) sync_target="$1"; shift ;;
            esac
        done
        sync_repos "$sync_target" "$sync_dry_run"
        ;;
    install)
        # Use ~/.local/bin for user-local installation
        target_dir="${HOME}/.local/bin"
        target="${target_dir}/skillsync"
        mkdir -p "$target_dir"
        cp "$0" "$target"
        chmod +x "$target"
        echo "âœ… SkillSync installed to $target"
        if [[ ":$PATH:" != *":$target_dir:"* ]]; then
            echo "âš  Warning: $target_dir is not in your PATH."
            echo "   Add 'export PATH=\"\$HOME/.local/bin:\$PATH\"' to your ~/.bashrc or ~/.zshrc."
        fi
        ;;
    *)
        cat << 'EOF'
Usage: skillsync <command> [args]

Commands:
  add-repo <url> [name] [initial_paths] [branch]   Add sparse submodule (name auto-extracted from URL if omitted)
  remove-repo [--soft|--hard] [--force] <name>    Remove repository (--soft preserves files)
  add <source> <path> [id]                 Activate skill
  remove <id>                              Deactivate skill
  list                                     List active skills
  restore                                  Restore symlinks from config
  status [repo-name]                       Show sync status of all/specific repos
  sync [repo-name] [--dry-run]             Pull upstream changes for all/specific repos
  install                                  Install SkillSync globally to ~/.local/bin

Examples:
  # Default: auto-extract repo name and add ALL skills from repository
  skillsync add-repo https://github.com/vercel-labs/agent-skills
  skillsync add-repo https://github.com/cloudflare/skills

  # Specific skills: auto-extract repo name but specify patterns
  skillsync add-repo https://github.com/vercel-labs/agent-skills "skills/react-best-practices/"
  skillsync add-repo https://github.com/cloudflare/skills "agents-sdk/"

  # Traditional: specify custom name
  skillsync add-repo https://github.com/base-org/skills base "skills/postgres-patterns/*"
  skillsync add-repo https://github.com/vercel-labs/agent-skills vercel "skills/" install

  # Repository management
  skillsync remove-repo vercel                    # Hard removal (default)
  skillsync remove-repo --soft vercel            # Soft removal (keeps files)

  # Skill management
  skillsync add agent-skills react-best-practices
  skillsync add skills agents-sdk
  skillsync list
  skillsync remove react-best-practices

  # Sync and status
  skillsync status                                    # Check all repos
  skillsync status vercel-labs-agent-skills            # Check specific repo
  skillsync sync                                      # Pull all upstream changes
  skillsync sync vercel-labs-agent-skills              # Pull specific repo
  skillsync sync --dry-run                             # Preview without updating
EOF
        ;;
esac
