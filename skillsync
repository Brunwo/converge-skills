#!/bin/bash
set -euo pipefail

SKILLS_ACTIVE="skills-active"
SKILLS_REPOS="skills-repos"
SKILLS_USER="skills-user"
CONFIG=".skillsync/active-skills.json"

# Initialize config directory
mkdir -p .skillsync

# Add sparse submodule
add_sparse_submodule() {
    local url=$1
    local name=$2
    local initial_paths=${3:-}
    local branch=${4:-}

    echo "Adding sparse submodule: $name"

    # Add as submodule (with optional branch)
    if [ -n "$branch" ]; then
        git submodule add -b "$branch" "$url" "$SKILLS_REPOS/$name"
    else
        git submodule add "$url" "$SKILLS_REPOS/$name"
    fi

    # Configure sparse checkout BEFORE cleaning
    cd "$SKILLS_REPOS/$name"
    git sparse-checkout init --cone
    git config core.sparseCheckout true

    # Clear working directory of tracked files not in sparse pattern
    git ls-files | grep -v '^\.git' | xargs -r rm -f
    # Also remove any remaining files/directories except .git
    find . -maxdepth 1 -name '.git' -prune -o -type f -print | grep -v '^\./\.git' | xargs -r rm -f
    find . -maxdepth 1 -name '.git' -prune -o -type d -print | grep -v '^\./\.git' | xargs -r rm -rf

    if [ -n "$initial_paths" ]; then
        git sparse-checkout set --skip-checks $initial_paths
    fi

    # Checkout only sparse files and update index
    git checkout
    git read-tree -mu HEAD  # Update index to match sparse patterns

    cd ../..

    # Save to .gitmodules metadata
    git config -f .gitmodules "submodule.$SKILLS_REPOS/$name.sparse" "true"
    git config -f .gitmodules "submodule.$SKILLS_REPOS/$name.sparse-checkout" "$initial_paths"
}

# Activate skills (create symlinks)
activate_skills() {
    local skills_json=$1

    # Create/clear active directory
    mkdir -p "$SKILLS_ACTIVE"

    # Remove old symlinks
    find "$SKILLS_ACTIVE" -type l -delete

    # Parse JSON and create symlinks
    echo "$skills_json" | jq -r '.[] | "\(.id)|\(.source)|\(.path)"' | while IFS='|' read -r id source path; do
        local target
        case "$source" in
            user)
                target="../$SKILLS_USER/$path"
                ;;
            *)
                target="../$SKILLS_REPOS/$source/skills/$path"
                ;;
        esac

        if [ -d "${target#../}" ]; then
            ln -sf "$target" "$SKILLS_ACTIVE/$id"
            echo "✓ Activated: $id → $target"
        else
            echo "⚠ Warning: $target not found, skipping $id"
        fi
    done

    # Save config
    echo "$skills_json" | jq '.' > "$CONFIG"
}

# Add skill to sparse checkout and activate
add_skill() {
    local source=$1
    local skill_path=$2
    local skill_id=${3:-$(basename "$skill_path")}

    # Update sparse checkout
    if [ "$source" != "user" ]; then
        cd "$SKILLS_REPOS/$source"
        git sparse-checkout add --skip-checks "skills/$skill_path/*"
        git checkout HEAD  # materialize files
        cd ../..

        # Update .gitmodules
        local current=$(git config -f .gitmodules "submodule.$SKILLS_REPOS/$source.sparse-checkout" || echo "")
        git config -f .gitmodules "submodule.$SKILLS_REPOS/$source.sparse-checkout" "$current skills/$skill_path/*"
    fi

    # Add to config
    local new_skill=$(jq -n \
        --arg id "$skill_id" \
        --arg source "$source" \
        --arg path "$skill_path" \
        '{id: $id, source: $source, path: $path}')

    if [ -f "$CONFIG" ]; then
        local updated=$(jq --argjson new "$new_skill" '. + [$new]' "$CONFIG")
    else
        local updated="[$new_skill]"
    fi

    activate_skills "$updated"
}

# Remove skill
remove_skill() {
    local skill_id=$1

    # Remove from config
    local updated=$(jq --arg id "$skill_id" 'map(select(.id != $id))' "$CONFIG")

    # Remove symlink
    rm -f "$SKILLS_ACTIVE/$skill_id"

    echo "$updated" | jq '.' > "$CONFIG"
    echo "✗ Deactivated: $skill_id"
}

# List active skills
list_skills() {
    if [ -f "$CONFIG" ]; then
        jq -r '.[] | "\(.id)\t(\(.source):\(.path))"' "$CONFIG"
    else
        echo "No skills activated yet"
    fi
}

# Restore from config (for post-clone/post-checkout)
restore() {
    if [ ! -f "$CONFIG" ]; then
        echo "No saved configuration found"
        exit 1
    fi

    local skills=$(cat "$CONFIG")
    activate_skills "$skills"
}

# Remove entire repository (and all its skills)
remove_repo() {
    local repo_name=$1
    local mode=${2:-hard}  # Default to hard removal
    local force=${3:-false}  # Default to no force

    echo "Removing repository: $repo_name (mode: $mode)"

    # For hard removal, check for uncommitted/unpushed changes
    if [ "$mode" = "hard" ] && [ "$force" = "false" ]; then
        if [ -d "skills-repos/$repo_name" ]; then
            cd "skills-repos/$repo_name"

            # Check for uncommitted changes
            if ! git diff --quiet --exit-code || ! git diff --cached --quiet --exit-code; then
                echo "❌ Error: Repository '$repo_name' has uncommitted changes."
                echo "   Use --force --hard to skip this safety check and lose changes."
                cd ../..
                exit 1
            fi

            # Check for unpushed commits
            local current_branch=$(git rev-parse --abbrev-ref HEAD)
            if git log --oneline --not --remotes | grep -q .; then
                echo "❌ Error: Repository '$repo_name' has local commits not pushed to remote."
                echo "   Use --force --hard to skip this safety check and lose commits."
                cd ../..
                exit 1
            fi

            cd ../..
        fi
    fi

    # Remove all skills from this repo
    if [ -f "$CONFIG" ]; then
        local updated=$(jq --arg repo "$repo_name" 'map(select(.source != $repo))' "$CONFIG")
        echo "$updated" | jq '.' > "$CONFIG"
    fi

    # Remove symlinks for this repo's skills
    find "$SKILLS_ACTIVE" -type l | while read -r link; do
        local target=$(readlink "$link")
        if [[ "$target" == *"../skills-repos/$repo_name"* ]]; then
            rm -f "$link"
        fi
    done

    if [ "$mode" = "hard" ]; then
        # Hard removal: delete submodule completely
        git submodule deinit -f "skills-repos/$repo_name"
        git rm -f "skills-repos/$repo_name"
        rm -rf ".git/modules/skills-repos/$repo_name"
        if [ "$force" = "true" ]; then
            echo "✗ Force hard removed repository: $repo_name (changes may be lost)"
        else
            echo "✗ Hard removed repository: $repo_name"
        fi
    else
        # Soft removal: unregister submodule and clean up directory
        git submodule deinit -f "skills-repos/$repo_name"
        git rm --cached "skills-repos/$repo_name" 2>/dev/null || true  # Remove from index if it exists

        # Clean up the directory (safe since files are preserved elsewhere if needed)
        if [ -d "skills-repos/$repo_name" ]; then
            rm -rf "skills-repos/$repo_name"
        fi

        echo "✗ Soft removed repository: $repo_name (submodule unregistered, directory cleaned)"
    fi
}

# Main command dispatcher
case "${1:-}" in
    add-repo)
        add_sparse_submodule "$2" "$3" "${4:-}" "${5:-}"
        ;;
    remove-repo)
        case "${2:-}" in
            --soft)
                remove_repo "$3" "soft" "false"
                ;;
            --force)
                case "${3:-}" in
                    --hard)
                        remove_repo "$4" "hard" "true"
                        ;;
                    *)
                        echo "❌ Error: --force must be used with --hard"
                        exit 1
                        ;;
                esac
                ;;
            --hard)
                remove_repo "$3" "hard" "false"
                ;;
            *)
                remove_repo "$2" "hard" "false"
                ;;
        esac
        ;;
    add)
        add_skill "$2" "$3" "${4:-}"
        ;;
    remove)
        remove_skill "$2"
        ;;
    list)
        list_skills
        ;;
    restore)
        restore
        ;;
    *)
        cat << 'EOF'
Usage: skillsync <command> [args]

Commands:
  add-repo <url> <name> [initial_paths] [branch]   Add sparse submodule
  remove-repo [--soft|--hard] [--force] <name>    Remove repository (--soft preserves files)
  add <source> <path> [id]                 Activate skill
  remove <id>                              Deactivate skill
  list                                     List active skills
  restore                                  Restore symlinks from config

Examples:
  skillsync add-repo https://github.com/base-org/skills base "skills/postgres-patterns/*"
  skillsync add-repo https://github.com/vercel-labs/agent-skills vercel "skills/" install
  skillsync remove-repo vercel                    # Hard removal (default)
  skillsync remove-repo --soft vercel            # Soft removal (keeps files)
  skillsync remove-repo --hard vercel            # Hard removal (explicit)
  skillsync remove-repo --force --hard vercel    # Force hard removal (skip safety checks)
  skillsync add base saas-multitenancy
  skillsync add user custom-stripe
  skillsync list
  skillsync remove saas-multitenancy
  skillsync restore
EOF
        ;;
esac
