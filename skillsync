#!/bin/bash
set -euo pipefail

SKILLS_ACTIVE="skills"
SKILLS_REPOS="skills-repos"
SKILLS_USER="skills-user"
CONFIG=".skillsync/active-skills.json"

# Config directory
mkdir_config() {
    mkdir -p .skillsync
}

# Ensure we are in a Git repository (except for 'install' and 'help')
check_git_repo() {
    if ! git rev-parse --is-inside-work-tree >/dev/null 2>&1; then
        echo "❌ Error: Not a git repository. SkillSync commands must be run from the root of a project."
        exit 1
    fi
}

# Derive user-repo name from git URL
get_repo_name() {
    local url=$1
    if [[ "$url" =~ github\.com[/:]([^/]+)/([^/.]+) ]]; then
        echo "${BASH_REMATCH[1]}-${BASH_REMATCH[2]}"
    else
        basename "$url" .git
    fi
}

# Add sparse submodule
add_sparse_submodule() {
    local url=$1
    local name=""
    local initial_paths=""
    local ref=""

    # URL is always $1
    url=$1

    # Always extract repo name from URL first
    if [[ "$url" =~ github\.com[/:]([^/]+)/([^/.]+) ]]; then
        local user="${BASH_REMATCH[1]}"
        local repo="${BASH_REMATCH[2]}"
        local default_name="${user}-${repo}"
    else
        # Fallback: use last part of URL
        local default_name=$(basename "$url" .git)
    fi

    # Check if $2 looks like patterns (contains / or starts with skills/)
    if [[ "$2" =~ / ]] || [[ "$2" =~ ^skills/ ]]; then
        # $2 looks like patterns, use default name from URL
        name="$default_name"
        initial_paths=$2
        ref=${3:-}
    else
        # Traditional format: url name [paths] [ref]
        # If $2 is provided and doesn't look like patterns, use it as custom name
        if [ -n "$2" ]; then
            name=$2
        else
            name="$default_name"
        fi
        initial_paths=${3:-}
        ref=${4:-}
    fi

    echo "Adding sparse submodule: $name (from $url)"

    # Handle case where directory exists but is not a git repo (e.g. after soft removal)
    if [ -d "$SKILLS_REPOS/$name" ] && [ ! -e "$SKILLS_REPOS/$name/.git" ]; then
        echo "⚠ Warning: Directory '$SKILLS_REPOS/$name' exists but is not a git repository. Clearing it for re-adding..."
        rm -rf "$SKILLS_REPOS/$name"
    fi

    # Add as submodule (with optional branch or commit) if not already in index
    if git ls-files --error-unmatch "$SKILLS_REPOS/$name" >/dev/null 2>&1; then
        echo "ℹ Repository '$name' already in index, skipping 'submodule add'"
    else
        if [ -n "$ref" ]; then
            # Check if it's a commit hash (40 characters, hex) or branch name
            if [[ "$ref" =~ ^[0-9a-f]{40}$ ]]; then
                # It's a commit hash - add submodule normally
                git submodule add -q "$url" "$SKILLS_REPOS/$name"
            else
                # It's a branch name - use -b flag
                git submodule add -q -b "$ref" "$url" "$SKILLS_REPOS/$name"
            fi
        else
            git submodule add -q "$url" "$SKILLS_REPOS/$name"
        fi
    fi

    # Configure sparse checkout (non-cone mode to allow excluding root files)
    cd "$SKILLS_REPOS/$name"
    git sparse-checkout init --no-cone >/dev/null 2>&1

    # Determine sparse checkout patterns
    local sparse_patterns=""
    if [ -n "$initial_paths" ]; then
        # User specified specific patterns
        sparse_patterns="$initial_paths"
        git sparse-checkout set --no-cone --skip-checks $sparse_patterns
    else
        # No patterns specified - add ALL skills from repository
        echo "No patterns specified, adding all skills from repository..."

        # Detect repository structure and collect all skills via ls-tree
        # This is more robust as it doesn't require materializing files first
        if git ls-tree -d HEAD skills/ >/dev/null 2>&1; then
            # Vercel-style: skills in subdirectory
            echo "Detected Vercel-style repository structure (skills/ subdirectory)"
            local skill_dirs=$(git ls-tree -d HEAD skills/ | awk '{print $4}')
            sparse_patterns=""
            for dir in $skill_dirs; do
                sparse_patterns="$sparse_patterns $dir/*"
            done
            sparse_patterns=$(echo "$sparse_patterns" | sed 's/^ *//')  # Remove leading space
        else
            # Cloudflare-style: skills in root or other structure
            echo "Detected root-level or Cloudflare-style repository structure"
            # Get top level directories, exclude common ones
            local skill_dirs=$(git ls-tree -d HEAD | grep '^04' | awk '{print $4}')
            sparse_patterns=""
            for dir in $skill_dirs; do
                # Skip common non-skill directories
                if [[ "$dir" != "docs" ]] && [[ "$dir" != "scripts" ]] && [[ "$dir" != ".github" ]]; then
                    sparse_patterns="$sparse_patterns $dir/*"
                fi
            done
            sparse_patterns=$(echo "$sparse_patterns" | sed 's/^ *//')  # Remove leading space
        fi

        if [ -n "$sparse_patterns" ]; then
            echo "Adding all skills: $sparse_patterns"
            git sparse-checkout set --no-cone --skip-checks $sparse_patterns
        else
            echo "Warning: No skills found in repository"
            sparse_patterns=""
        fi
    fi

    # Now checkout the specific commit or update working tree to patterns
    if [[ "$ref" =~ ^[0-9a-f]{40}$ ]]; then
        git checkout -q "$ref"
    else
        git checkout -q HEAD
    fi

    cd ../..

    # Save to .gitmodules metadata
    git config -f .gitmodules "submodule.$SKILLS_REPOS/$name.sparse" "true"
    git config -f .gitmodules "submodule.$SKILLS_REPOS/$name.sparse-checkout" "$sparse_patterns"
}

# Activate skills (create symlinks)
activate_skills() {
    local skills_json=$1

    # Create/clear active directory
    mkdir -p "$SKILLS_ACTIVE"

    # Remove old symlinks
    find "$SKILLS_ACTIVE" -type l -delete

    # Parse JSON and create symlinks
    echo "$skills_json" | jq -r '.[] | "\(.id)|\(.source)|\(.path)"' | while IFS='|' read -r id source path; do
        local target
        case "$source" in
            user)
                target="../$SKILLS_USER/$path"
                ;;
            *)
                local repo_dir="$source"
                # If the exact source dir doesn't exist, try to find a matching one
                if [ ! -d "$SKILLS_REPOS/$repo_dir" ]; then
                    local match=$(ls "$SKILLS_REPOS" 2>/dev/null | grep "$source" | head -n 1 || echo "")
                    if [ -n "$match" ]; then
                        repo_dir="$match"
                    fi
                fi

                # Check for both repository structures: with and without skills/ subdirectory
                if [ -d "$SKILLS_REPOS/$repo_dir/skills/$path" ]; then
                    target="../$SKILLS_REPOS/$repo_dir/skills/$path"
                elif [ -d "$SKILLS_REPOS/$repo_dir/$path" ]; then
                    target="../$SKILLS_REPOS/$repo_dir/$path"
                else
                    target="../$SKILLS_REPOS/$repo_dir/skills/$path"  # Default to skills/ subdirectory
                fi
                ;;
        esac

        if [ -d "${target#../}" ]; then
            ln -sf "$target" "$SKILLS_ACTIVE/$id"
            echo "✓ Activated: $id → $target"
        else
            echo "⚠ Warning: $target not found, skipping $id"
        fi
    done

    # Save config
    echo "$skills_json" | jq '.' > "$CONFIG"
}

# Add skill or repo (handles both URLs and source names)
add_skill_or_repo() {
    local arg1="${1:-}"
    local arg2="${2:-.}"
    local arg3="${3:-}"
    local arg4="${4:-}"
    
    # Check if arg1 is a URL
    if [[ "$arg1" =~ ^https?:// ]]; then
        # URL provided - call add-repo then optionally add specific skill
        local url="$arg1"
        local path="$arg2"
        local ref="$arg3"
        
        # First ensure the repo exists and is configured
        local repo_name=$(get_repo_name "$url")
        local has_patterns=$(git config -f .gitmodules "submodule.$SKILLS_REPOS/$repo_name.sparse-checkout" || echo "")
        
        if [ ! -d "$SKILLS_REPOS/$repo_name" ] || [ -z "$has_patterns" ]; then
            # Add or re-configure the repo
            add_sparse_submodule "$url" "" "" "$ref"
        fi
        
        if [ "$path" != "." ]; then
            add_skill "$repo_name" "$path" "$arg4"
        else
            # Auto-activate all skills found in the repo
            echo "Auto-activating all skills from $repo_name..."
            local patterns=$(git config -f .gitmodules "submodule.$SKILLS_REPOS/$repo_name.sparse-checkout" || echo "")
            if [ -z "$patterns" ]; then
                echo "⚠ No patterns found for $repo_name, skipping auto-activation"
            else
                for pattern in $patterns; do
                    # Clean up pattern (e.g. "skills/foo/*" -> "foo")
                    local clean_path=$(echo "$pattern" | sed 's|/\*$||' | sed 's|^skills/||')
                    if [ -n "$clean_path" ]; then
                        add_skill "$repo_name" "$clean_path" "" "skip-activation"
                    fi
                done
                restore
            fi
        fi
    else
        # Source name provided - existing workflow
        add_skill "$arg1" "$arg2" "$arg3"
    fi
}

# Add skill to sparse checkout and activate
add_skill() {
    local source=$1
    local skill_path=$2
    local skill_id=${3:-$(basename "$skill_path")}

    # Update sparse checkout
    if [ "$source" != "user" ]; then
        cd "$SKILLS_REPOS/$source"

        if [ -d "skills/$skill_path" ]; then
            # Repository has skills/ subdirectory (like Vercel)
            git sparse-checkout add --skip-checks "skills/$skill_path/*" >/dev/null 2>&1
            git checkout -q HEAD  # materialize files
        elif [ -d "$skill_path" ]; then
            # Repository has skills directly in root (like Cloudflare)
            git sparse-checkout add --skip-checks "$skill_path" >/dev/null 2>&1
            git checkout -q HEAD  # materialize files
        fi

        cd ../..

        # Update .gitmodules (only if we added a skills/ pattern)
        if [ -d "$SKILLS_REPOS/$source/skills/$skill_path" ]; then
            local current=$(git config -f .gitmodules "submodule.$SKILLS_REPOS/$source.sparse-checkout" || echo "")
            git config -f .gitmodules "submodule.$SKILLS_REPOS/$source.sparse-checkout" "$current skills/$skill_path/*"
        fi
    fi

    # Add to config
    local new_skill=$(jq -n \
        --arg id "$skill_id" \
        --arg source "$source" \
        --arg path "$skill_path" \
        '{id: $id, source: $source, path: $path}')

    if [ -f "$CONFIG" ]; then
        local updated=$(jq --argjson new "$new_skill" '. + [$new]' "$CONFIG")
    else
        local updated="[$new_skill]"
    fi

    if [ "${4:-}" != "skip-activation" ]; then
        activate_skills "$updated"
    else
        # Save config even if skipping activation
        echo "$updated" | jq '.' > "$CONFIG"
    fi
}

# Remove skill
remove_skill() {
    local skill_id=$1

    # Remove from config
    local updated=$(jq --arg id "$skill_id" 'map(select(.id != $id))' "$CONFIG")

    # Remove symlink
    rm -f "$SKILLS_ACTIVE/$skill_id"

    echo "$updated" | jq '.' > "$CONFIG"
    echo "✗ Deactivated: $skill_id"
}

# Deactivate all skills associated with a repository
deactivate_repo_skills() {
    local repo_name=$1
    
    echo "Deactivating all skills from repository: $repo_name"

    # Remove all skills from this repo from the config
    if [ -f "$CONFIG" ]; then
        local updated=$(jq --arg repo "$repo_name" 'map(select(.source != $repo))' "$CONFIG")
        echo "$updated" | jq '.' > "$CONFIG"
    fi

    # Remove symlinks for this repo's skills
    if [ -d "$SKILLS_ACTIVE" ]; then
        # Find all symlinks in skills/ that point to the target repo and remove them
        # We use a pattern that matches the relative symlink target structure
        find "$SKILLS_ACTIVE" -type l -lname "*../$SKILLS_REPOS/$repo_name/*" -delete
    fi
}

# Remove skill or repo (handles both URLs and skill IDs)
remove_skill_or_repo() {
    local arg1="${1:-}"
    local arg2="${2:-}"
    
    # Check if arg1 is a URL
    if [[ "$arg1" =~ ^https?:// ]]; then
        # URL provided - extract repo name
        local repo_name=$(get_repo_name "$arg1")
        
        if [ -n "$arg2" ]; then
            # Specific skill deactivated from this repo
            # Search for skill matching this source and (path or id)
            local skill_id=$(jq -r --arg src "$repo_name" --arg p "$arg2" '.[] | select(.source == $src and (.path == $p or .id == $p)) | .id' "$CONFIG" 2>/dev/null | head -n 1 || echo "")
            
            if [ -n "$skill_id" ]; then
                remove_skill "$skill_id"
            else
                # Also try matching by basename of path
                skill_id=$(jq -r --arg src "$repo_name" --arg p "$arg2" '.[] | select(.source == $src and (.path | endswith($p))) | .id' "$CONFIG" 2>/dev/null | head -n 1 || echo "")
                if [ -n "$skill_id" ]; then
                    remove_skill "$skill_id"
                else
                    echo "⚠ Warning: Skill '$arg2' not found in repository '$repo_name' (active-skills.json)"
                fi
            fi
        else
            # Deactivate all skills from this repo
            deactivate_repo_skills "$repo_name"
            echo "✗ Deactivated all skills from: $arg1 (repository preserved)"
        fi
    else
        # Skill ID provided
        remove_skill "$arg1"
    fi
}

# List active skills
list_skills() {
    if [ -f "$CONFIG" ]; then
        jq -r '.[] | "\(.id)\t(\(.source):\(.path))"' "$CONFIG"
    else
        echo "No skills activated yet"
    fi
}

# Restore from config (for post-clone/post-checkout)
restore() {
    if [ ! -f "$CONFIG" ]; then
        echo "No saved configuration found"
        exit 1
    fi

    local skills=$(cat "$CONFIG")
    activate_skills "$skills"
}

# Remove entire repository (and all its skills)
remove_repo() {
    local repo_name=$1
    local mode=${2:-hard}  # Default to hard removal
    local force=${3:-false}  # Default to no force

    echo "Removing repository: $repo_name (mode: $mode)"

    # For hard removal, check for uncommitted/unpushed changes
    if [ "$mode" = "hard" ] && [ "$force" = "false" ]; then
        if [ -d "skills-repos/$repo_name" ]; then
            cd "skills-repos/$repo_name"

            # Check for uncommitted changes
            if ! git diff --quiet --exit-code || ! git diff --cached --quiet --exit-code; then
                echo "❌ Error: Repository '$repo_name' has uncommitted changes."
                echo "   Use --force --hard to skip this safety check and lose changes."
                cd ../..
                exit 1
            fi

            # Check for unpushed commits
            local current_branch=$(git rev-parse --abbrev-ref HEAD)
            if git log --oneline --not --remotes | grep -q .; then
                echo "❌ Error: Repository '$repo_name' has local commits not pushed to remote."
                echo "   Use --force --hard to skip this safety check and lose commits."
                cd ../..
                exit 1
            fi

            cd ../..
        fi
    fi

    # Deactivate all skills from this repo
    deactivate_repo_skills "$repo_name"

    if [ "$mode" = "hard" ]; then
        # Hard removal: delete submodule completely
        git add .gitmodules 2>/dev/null || true
        git submodule deinit -f "skills-repos/$repo_name"
        git rm -f "skills-repos/$repo_name"
        rm -rf ".git/modules/skills-repos/$repo_name"
        if [ "$force" = "true" ]; then
            echo "✗ Force hard removed repository: $repo_name (changes may be lost)"
        else
            echo "✗ Hard removed repository: $repo_name"
        fi
    else
        # Soft removal: unregister submodule but keep the files (only remove active skill symlinks)
        git submodule deinit -f "skills-repos/$repo_name" 2>/dev/null || true

        # Stage .gitmodules changes first, then remove from index and .gitmodules
        git add .gitmodules 2>/dev/null || true
        git rm --cached "skills-repos/$repo_name" 2>/dev/null || true  # Remove from index only, keep files

        # Clean up .gitmodules section explicitly
        git config -f .gitmodules --remove-section "submodule.skills-repos/$repo_name" 2>/dev/null || true
        git add .gitmodules 2>/dev/null || true

        # Clean up any leftover git modules
        if [ -d ".git/modules/skills-repos/$repo_name" ]; then
            rm -rf ".git/modules/skills-repos/$repo_name"
        fi

        echo "✗ Soft removed repository: $repo_name (files preserved, symlinks removed)"
    fi
}

# Main command dispatcher
case "${1:-}" in
    add-repo)
        check_git_repo
        mkdir_config
        # Handle variable number of arguments for add-repo
        arg2="${2:-}"
        arg3="${3:-}"
        arg4="${4:-}"
        arg5="${5:-}"
        add_sparse_submodule "$arg2" "$arg3" "$arg4" "$arg5"
        ;;
    remove-repo)
        check_git_repo
        shift
        repo_name=""
        mode="hard"
        force="false"

        while [ $# -gt 0 ]; do
            case "$1" in
                --soft)
                    mode="soft"
                    shift
                    ;;
                --hard)
                    mode="hard"
                    shift
                    ;;
                --force)
                    force="true"
                    shift
                    ;;
                -*)
                    echo "❌ Error: Unknown option $1"
                    exit 1
                    ;;
                *)
                    if [ -z "$repo_name" ]; then
                        repo_name="$1"
                    else
                        echo "❌ Error: Multiple repository names provided: $repo_name, $1"
                        exit 1
                    fi
                    shift
                    ;;
            esac
        done

        if [ -z "$repo_name" ]; then
            echo "❌ Error: Repository name not provided"
            exit 1
        fi

        if [ "$force" = "true" ] && [ "$mode" != "hard" ]; then
            echo "❌ Error: --force must be used with --hard"
            exit 1
        fi

        remove_repo "$repo_name" "$mode" "$force"
        ;;
    add)
        check_git_repo
        mkdir_config
        add_skill_or_repo "$2" "${3:-.}" "${4:-}" "${5:-}"
        ;;
    remove)
        check_git_repo
        remove_skill_or_repo "$2" "${3:-}"
        ;;
    list)
        check_git_repo
        list_skills
        ;;
    restore)
        check_git_repo
        restore
        ;;
    install)
        # Use ~/.local/bin for user-local installation
        target_dir="${HOME}/.local/bin"
        target="${target_dir}/skillsync"
        mkdir -p "$target_dir"
        cp "$0" "$target"
        chmod +x "$target"
        echo "✅ SkillSync installed to $target"
        if [[ ":$PATH:" != *":$target_dir:"* ]]; then
            echo "⚠ Warning: $target_dir is not in your PATH."
            echo "   Add 'export PATH=\"\$HOME/.local/bin:\$PATH\"' to your ~/.bashrc or ~/.zshrc."
        fi
        ;;
    *)
        cat << 'EOF'
Usage: skillsync <command> [args]

Commands:
  add-repo <url> [name] [initial_paths] [branch]   Add sparse submodule (name auto-extracted from URL if omitted)
  remove-repo [--soft|--hard] [--force] <name>    Remove repository (--soft preserves files)
  add <source> <path> [id]                 Activate skill
  remove <id>                              Deactivate skill
  list                                     List active skills
  restore                                  Restore symlinks from config
  install                                  Install SkillSync globally to ~/.local/bin

Examples:
  # Default: auto-extract repo name and add ALL skills from repository
  skillsync add-repo https://github.com/vercel-labs/agent-skills
  skillsync add-repo https://github.com/cloudflare/skills

  # Specific skills: auto-extract repo name but specify patterns
  skillsync add-repo https://github.com/vercel-labs/agent-skills "skills/react-best-practices/"
  skillsync add-repo https://github.com/cloudflare/skills "agents-sdk/"

  # Traditional: specify custom name
  skillsync add-repo https://github.com/base-org/skills base "skills/postgres-patterns/*"
  skillsync add-repo https://github.com/vercel-labs/agent-skills vercel "skills/" install

  # Repository management
  skillsync remove-repo vercel                    # Hard removal (default)
  skillsync remove-repo --soft vercel            # Soft removal (keeps files)

  # Skill management
  skillsync add agent-skills react-best-practices
  skillsync add skills agents-sdk
  skillsync list
  skillsync remove react-best-practices
EOF
        ;;
esac
